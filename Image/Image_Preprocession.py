# -*- coding: utf-8 -*-
"""Image_Prepro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tRH-wPIEHCy9PaNLENBXaiFmAt8n686v

# Load Image
"""

import cv2
import os

# Load full resolution image
image_full = cv2.cvtColor(cv2.imread('/content/SatDat'), cv2.COLOR_BGR2RGB)

image_full

"""Resizing"""

# resize full image to a consistent scale
# width: 240, height: 320
image_resized = cv2.resize(image_full, (240,320))
image_resized

# resize to a different scale
# square image
# width: 120, height: 120
image_resized_2 = cv2.resize(image_full, (120,120))

image_resized_2

from PIL import Image
image_pil_full = Image.open('/content/SatDat')
# resize image to width: 240, height: 320
image_pil_resized = image_pil_full.resize((240, 320))

image_pil_resized

# resize image to width: 240, height: 320
image_pil_resized = image_pil_full.resize((240, 320))

image_pil_resized

"""Crop"""

#let's use full resolution image
image_full = cv2.cvtColor(cv2.imread('/content/SatDat'), cv2.COLOR_BGR2RGB)

# decide the area to crop
# x: start of x axis
# y: start of y axis
# w: width of pixels to crop
# h: height of pixels to crop
x, y, w, h = 2000, 1750, 300, 400

# crop image
image_cropped = image_full[y:y+h, x:x+w]

image_cropped

"""# Normalization

Rescaling grayscale image
"""

# load image_230x240 as grayscale
image_small_gs = cv2.imread('/content/SatDat',cv2.IMREAD_GRAYSCALE)

# normalizing to 0-1 range
normalized_image = image_small_gs/255

normalized_image

# load image_230x240 as grayscale
image_small = cv2.cvtColor(cv2.imread('/content/SatDat'), cv2.COLOR_BGR2RGB)

# split image to
r, g, b = cv2.split(image_small)

r

"""# Noise Reduction"""

import cv2
# additional function if using Colab
from google.colab.patches import cv2_imshow
import numpy as np
# use small image
# kernel is used to adjust blurring
# Gaussian Blurring
# need to specify width and height of kernel, should be positive and odd
gaussianblur_image = cv2.GaussianBlur(image_small, (3,3), 0)

# Display the result
cv2_imshow(gaussianblur_image)

cv2.waitKey(0)
cv2.destroyAllWindows()

"""Blur"""

# Median Blurring
medianblur_image = cv2.medianBlur(image_small,3)

medianblur_image

"""Rotation"""

import cv2
# additional function if using Colab
from google.colab.patches import cv2_imshow
import numpy as np

# obtain image dimensions
height, width = image_small_gs.shape[:2]

# defining the rotation center
center = (width // 2, height // 2)

# defining the rotation angle
angle = 45

# defining the scaling factor
scale = 1.0

# getting the rotation matrix
rotation_matrix = cv2.getRotationMatrix2D(center, angle, scale)
rotated_image = cv2.warpAffine(image_small_gs, rotation_matrix, (width, height))

# Display the result
cv2_imshow(rotated_image)

cv2.waitKey(0)
cv2.destroyAllWindows()

"""Translation: shifting an image along the x-axis and y-axis"""

# defining translation values
tx, ty = 100, 50  # Shift 100 pixels right and 50 pixels down

# creating the translation matrix
translation_matrix = np.float32([
    [1, 0, tx],
    [0, 1, ty]
])

# image dimensions
height, width = image_small_gs.shape[:2]

translated_image = cv2.warpAffine(image_small_gs, translation_matrix, (width, height))

# display the result
cv2_imshow(translated_image)

cv2.waitKey(0)
cv2.destroyAllWindows()

"""Flip"""

# Vertical flip
flipped_vertically = cv2.flip(image_small_gs, 0)

# Horizontal flip
flipped_horizontally = cv2.flip(image_small_gs, 1)

# Horizontal + vertical flip
flipped_both = cv2.flip(image_small_gs, -1)

# display the flipped images
cv2_imshow(flipped_vertically)
cv2_imshow(flipped_horizontally)
cv2_imshow(flipped_both)

cv2.waitKey(0) # Wait indefinitely until a key is pressed
cv2.destroyAllWindows() # Close all OpenCV windows

"""Edge Detection"""

# Sobel operator
sobelx = cv2.Sobel(image_small_gs, cv2.CV_64F, 1, 0, ksize=3)  # Horizontal edges
sobely = cv2.Sobel(image_small_gs, cv2.CV_64F, 0, 1, ksize=3)  # Vertical edges

# Compute gradient magnitude
gradient_magnitude = cv2.magnitude(sobelx, sobely)

# Convert to uint8
gradient_magnitude = cv2.convertScaleAbs(gradient_magnitude)

# Display result
cv2_imshow(gradient_magnitude)

cv2.waitKey(0)
cv2.destroyAllWindows()